

## This function creates a special "matrix" object that can cache its inverse
makeCacheMatrix<-function (x=matrix())
{
  m <- NULL
  
  ## condition to check if count has be initilaized, if it hasnt been it will be
  ## initialized to zero else it will preserve its global count
  ## count is incremented by 1 everytime the function cache solve is run and not 
  ## reset in the makeCacheMatrix function
  
  if(!exists("count"))
  {
    count<<-0
  }
  
  ## Set the matrix value passed to function makeCacheMatrix   
  set<- function(z){
    x <<-z
    m<<-NULL
  }
  
  ## Gets the value of matrix passed to function makeCacheMatrix
  ## This function is called from cachesolve function to get the value of assigned to
  ## matrix made by makeCacheMatrix
  get<- function() x
  
  
  ## Sets the value of the inverse matrix called from cachesolve  
  setINV <- function(solve) m<<-solve
  
  ## Gets the value of the inverse matrix called from cachesolve, it gets the value NULL
  ## when a new matrix is used for the first time
  getINV<- function() m
  
  ## The output of the function is a list of functions as defined above
  
  list (set=set, get=get, setINV=setINV, getINV=getINV)
}



## The code checks for same matrix as last input to be the same as the present under the name of special matrix generated by 
## the above function or the same matrix input under a new name. If the matrix input is same as last it goes to cache 
## else solves a fresh.

cachesolve <- function(x, ...) {
  
  #returns the value of the function getInv as Null if the matrix 'x' generated
  ## by makeCacheMatrix is new. So everytime makeCacheMatrix will run m will be reset 
  ## to null
  m <- x$getINV()
  count <<- count+1
  
  
  ## everytime makeCachematrix is re-run the value of m will be set to null, if 
  ## makecachematrix is not re-run then no new matrix is generated and thus we can 
  ## return cache value of the inverse matrix
  
  if(!is.null(m)) {
    message("getting cached data")
    return(m)
  }

  ## Function to compare to matrices values and dimensions and return true and false
  ## as output
  mat_equality <- function(x, y) {
    is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y) 
  }
  ## If it is first run of the cache solve function there is no inverese matrix in the
  ## cache yet and thus these steps of matrix comparison can be skipped
  ## Matrix comparison becomes neccessary as if we use the makeCacheMatrix function
  ## multiple times, m will be set to Null and the code would recalculate the inverse matrix
  ## the check below enables us to compare the last matrix in the cache to the current 
  ## one and if they have identical dimensions and elsements to go retrive the inverse from 
  ## the cache rather than re-calculating.
  if (count!=1) { 
    data1<-x$get()
    
   
    
    if(mat_equality(data1,data2)== TRUE)
    {
      message("getting cached data")
      return(m2)
    }
    }

  ## if the current matrix input is not identical to the one previously processed,
  ## we calculate the inverse matrix afresh and store in the cache
 
  
  data2<<- x$get()
  m2 <<- solve(data2, ...)
  x$setINV(m2)
 
  m2
}
