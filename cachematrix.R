

## This function creates a special "matrix" object that can cache its inverse. The function
## uses intilizes a counter "count' to keep a track of the number of times the cachesolve function
## is run after the first call the makeCacheMatrix function. This counter is used in the cachesolve function
## later and is explained there. 
## The function returns a list, containing a function to 
## 1) Set the value of the invertable input matrix
## 2) Get the value of the invertable input matrix
## 3) Set the value of the inverse of the input matrix
## 4) Get the value of the inverse of the input matrix

makeCacheMatrix<-function (x=matrix())
{
  m <- NULL   ## value of m is initialized to Null every time the function is called
  
  if(!exists("count"))  ## the command exists returns true or false if the variable count has been defined
  {                     ## in case not defined yet it is set to zero else the global value persists
    count<<-0           ## as detailed above this is used in the cachesolve function and covered there
  }
  
  set<- function(z)     ## Set the matrix value passed to function makeCacheMatrix
  {        
    x <<-z
    m<<-NULL
  }
  
   get<- function() x   ## Gets the value of matrix passed to function makeCacheMatrix
                        ## This function is called from cachesolve function to get the value of assigned to
                        ## matrix made by makeCacheMatrix
  
  
  
 setINV <- function(solve) m<<-solve  ## Sets the value of the inverse matrix called from cachesolve  
  
  
  getINV<- function() m        ## Gets the value of the inverse matrix called from cachesolve, it gets the value NULL
                               ## when a new matrix is used 
  
  
 list (set=set, get=get, setINV=setINV, getINV=getINV) ## The output of the function is a list of functions as defined above
}



## The following function calculates the inverse of the special matrix created with the above makeCacheMatrix function.
## It first checks whether the inverse of the special matrix has already been calculated if so it pulls the value  of
## the inverse from the cache.
## In case the value of the special matrix hasn't already been calculated, it checks if the new special matrix created 
## is same as the one last used just having a different name. If so, it pulls the value from the cache
## If the above two conditions are not met, it computes a new value

cachesolve <- function(x, ...) 
{
  
  m <- x$getINV()         ##returns the value of the function getInv for the special matrix 'x' input to the function
                          
  
  count <<- count+1       ## Counter to check number of times the function cachesolve is run
  
  
  if(!is.null(m))                 ## If a  special matrix has not already been inverted the value of m will not be null 
  {                               ## in such a case the cache value of m will be returned. 
  message("getting cached data")  ## However everytime a new special matrix is generated by makeCacheMatrix command m 
  return(m)                       ## is reset to null and thus a new speaical matrix generated with a new name but with 
  }                               ## identical contents as the previous one will not be caught here.
    
  

  
  mat_equality <- function(x, y)       ## Function to compare the values and dims of two matrices and return true and false
  {
    is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y) 
  }
  
  
  
  if (count!=1)                    #The counter is used to check if the cachesolve function is run for the first time, 
  {                                # if it is true, there is no inverse matrix in the cache and this code segment can be skipped
    data1<-x$get()                             # Gets the data corresponding to the input variable to the function and
    if(mat_equality(data1,data2)== TRUE)       # compares it with the last run input data, if it is the same then
    {                                          # returns the inverse matrix from the cache and does not re-calculate it
      message("getting cached data")
      return(m2)
    }
  }

  data2<<- x$get()                 # If the special matrix generated by makeCachematrix is indeed new and not a duplicate
  m2 <<- solve(data2, ...)         # copy of the one used in the last run of the function, then the inverse of the special
  x$setINV(m2)                     # matrix is calculated afresh
 
  m2                               # returns the value of the inverse matrix as the output of the function                  
}
